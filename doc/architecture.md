Общие мысли:
http://engineering.appfolio.com/2012/11/16/css-architecture/
http://nicolasgallagher.com/about-html-semantics-front-end-architecture/
http://philipwalton.com/articles/css-architecture/

Мысли Гарри Робертса об архитектуре:
http://csswizardry.com/2013/05/hashed-classes-in-css/
http://csswizardry.com/2012/10/a-classless-class-on-using-more-classes-in-your-html/
http://csswizardry.com/2012/07/shoot-to-kill-css-selector-intent/
http://csswizardry.com/2012/05/keep-your-css-selectors-short/
http://csswizardry.com/2013/05/scope-in-css/
http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/
http://csswizardry.com/2013/01/you-know-your-context-on-critical-thinking-and-thinking-for-yourself/

Методологии
http://smacss.com/
http://ru.bem.info/method/
http://operatino.github.io/MCSS/


Особый диалект БЭМ-именования на ВерблюжьемСтиле

Представим, что необходимо сверстать виджет с акциями, в котором должен быть заголовок и список акций. Можно с этой задачей справиться и так:

    <div id="actions">
      <h3>Header</h3>
      <ul>
        <li>item1</li>
        <li>item2</li>
        <li>item3</li>
      </ul>
    </div>

    div#actions {...}
    div#actions h3 {...}
    div#actions ul {...}
    div#actions li {...}

Теперь, если будет нужно добавить внутрь элемента списка ешё один список, придётся писать уже более длинный и более бессмысленный селектор `div#actions li li`, стилями которого придётся перебарывать стили `div#actions li`.
Проблема возникнет и в том случае, когда потребуется сверстать точно такой же виджет, только для товаров. В этих ситуациях использовать такую же вёрстку не получится (нам же не нужно, чтобы виджет с товарами был с классом `actions`). Из-за этого приходится заново копировать или даже придумывать вёрстку заново.

Чтобы получить универсальный элемент, способный использоваться снова и снова, нужно сверсать его немного по-другому.
Ко всему прочему, его элементы также должны быть переносимы и быть способны использоваться отдельно даже от их контейнера (мало ли куда их ТЗ занесёт).

Вспомним, что требуется: виджет с заголовком и списком. Список, ко всему прочему, с акциями.

    <div class="widget actions">
      <h3 class="widgetHeader"></h3>
      <ul class="widgetList">
        <li class="widgetListItem"></li>
        <li class="widgetListItem"></li>
        <li class="widgetListItem"></li>
      </ul>
    </div>

Поясню изменения: виджет — смысл жизни этого контейнера, поэтому и класс его семантичен — `widget`. У виджета может быть заголовок `.widgetHeader`. В виджет вставляется его список `.widgetList`, а элементы его — `.widgetListItem`. Контейнер модифицируется при помощи класса `actions`.

Да, на первоначальное построение блока будет уходить больше времени, чем на «просто вёрстку». Но это время компенсируется на других этапах, когда заново перевёрстывать не будет необходимости.


Почему элементам нужно добавлять так много классов? Почему бы не добавить только несколько, а остальные элементы стилизовать каскадом?

Потому что каскад лишает вёрстку гибкости, вёрстка попадает в зависимость от положения элементов в документе, от их количества, от их состояния.

Мне понравилась аналогия из [этой статьи](http://csswizardry.com/2012/10/a-classless-class-on-using-more-classes-in-your-html/)
Представьте, что вы учитель и пытаетесь успокоить детей, у которых нет имён. Таким образом,
парень через два ряда: `el:nth-of-type(){}`
ребёнок рядом с девочкой рядом с ребёнком под лампой: `el el + el{}`
девочка недалеко от окна: `el + el {}`
первый парень, сидящий на застеленной ковром зоне: `el > el:first-of-type{}`.

Конечно, такая аналогия утрирована, но посыл верный — именно так верстается без должного применения классов.

Помните, всегда лучше написать не `#itemsList li div { }`, а `.mainNavSub { }`. Ещё одна аналогия на эту тему [в этой статье](http://engineering.appfolio.com/2012/11/16/css-architecture/): думайте о селекторе `#itemsList li div { }`, как о гранате, а о `.mainNavSub { }`, как о снайперской винтовке. Граната может отлично помочь сегодня, но никто не знает, когда невинный гражданин может попасть в зону поражения.
//
Когда не ясно, _что принесёт завтрашний день_, когда вёрстка всей страницы может _полностью измениться из-за перевернувшихся концепций_ или из-за _внезапного осознания ущербности согодняшней вёрстки_, именно тогда возможность изменить поведение и отображение элементов на странице становится как никогда актуальной.
//


Если искать аналогии с программированием, все селекторы в стилях находятся в глобальной области видимости, то есть могут влиять на любой другой элемент, если не пытаться изолировать их, отделить друг от друга.
Именно в этот момент можно вспомнить о замыкании.
Необходимо выработать способ подбора классов для элементов, чтобы их стили не пересекались друг с другом.



Чтобы не было проблем в будущем, нужно максимально качественно сделать работу в настоящем.



**Блок** — совокупность разнородных элементов, связанных общим назначением.
**Элемент** — составляющая часть блока, способная использоваться отдельно от него и друг от друга, но дополняющая друг друга, находясь рядом.
Отображение и поведение элементов и самого блока может изменяться **модификаторами**.
**Блок** состоит из _корневого элемента_ и _частей_, входящих в него. Для простоты именования говорится, что _корневой элемент_ сам является **блоком**, а входящие в него _элементы_ так и называются — **элементами**. Части и сам блок могут изменяться **модификаторами**. Да, это примерно так же, как и в яндексовском БЭМе.



Класс блока должен начинаться с большой буквы. Если блок — кнопка, то имя его класса может быть `Btn`.

Класс элемента образуется от класса блока, в котором этот элемент находится, и слова, обозначающего предназначение элемента.
Если элемент — составная часть кнопки, отвечающая за её основное действие, то его класс может быть `BtnAction`.

Класс модификатора пишется с маленькой буквы, вместе с классом модифицируемого элемента.

Классы блоков и элементов указываются в селекторах по одному, если не изменяются модификаторами.
Модификатор указывается вместе с элементом, к которому применяется.
Если модификатор окрашивает кнопку в цвет ошибки, его класс может быть `error`, а селектор `.Btn.error`.

// Написать про положение в файле цсс.


Мне не нравится идея с добавлением слова `Block` в класс блока, ведь есть блоки, для которых такое указание лишнее (например, кнопки), а вносить дополнительные условия добавления такого слова мне не хочется.


Если вы заметили, что селектор превращается в башню:

    .pageActions .itemPhoto,
    .pageSpecial .itemPhoto,
    .relatedItems .itemPhoto
    .pageNews .itemPhoto {
      ...
    }

То выделите такие стили в модификатор

    .itemPhoto.small {
      ...
    }


Важнейшее качество вёрстки — гибкость, то есть возможность использовать все элементы многократно, в разных условиях и окружениях. Гибкость обеспечивается, в первую очередь, независимостью элементов.



В БЭМ для обозначения блока используется префикс `b-`.
[Николас Галлахер](http://nicolasgallagher.com/) пишет название блока с большой буквы. [Гарри Робертс](http://csswizardry.com/) [предлагает](http://csswizardry.com/2013/05/hashed-classes-in-css/) использовать для такого уточнения использовать символ идентификатора — `#`.

Вообще, в разных методологиях такие элементы (или их группы) называются по-разному: Блок, Модуль, Группа.
Так как слово Фундамент по смыслу ближе к строительству, будет использоваться строительное понятие Блок.
Таким образом класс элементу нужно дать `goodsListBlock`, а его элементы называть, учитывая только `goodsList`.



Создавая для себя удобства в виде переиспользуемых блоков, не нужно забывать и о других разработчиках, которым они могут пригодиться. Поэтому много времени нужно уделять документированию всего, что вы делаете.

Айконс: Перенести верхний маргин в модификатор.